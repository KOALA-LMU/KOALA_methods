pi <- 0.06
n <- 1000
z <- 1.96
qnorm(0.975)
z <- qnorm(0.975)
ci_var <- function(p, n) { qnorm(0.975)*sqrt(p*(1-p)/n) }
rm(pi)
p <- 0.06
ci_var(p,n)
ci_var(p,1500)
sqrt(p*(1-p)/n)
ci_var(0.03,1500)
ci_var <- function(p, n, alpha = 0.05) { qnorm(1-alpha/2)*sqrt(p*(1-p)/n) }
ci_var(0.03,1500, alpha = 0.01)
ci_var(0.03,1339, alpha = 0.01)
library(coalitions)
library(coalishin)
surveys <- coalitions::scrape_by()
surveys
coalitions::pool_surveys(surveys)
data <- get_surveys_by() %>%
mutate(pollster = replace(pollster, pollster == "infratestdimap", "infratest")) %>%
filter(pollster != "pollytix") %>%
arrange(pollster)
library(dplyr)
library(tidyr)
data <- get_surveys_by() %>%
mutate(pollster = replace(pollster, pollster == "infratestdimap", "infratest")) %>%
filter(pollster != "pollytix") %>%
arrange(pollster)
data
coalitions::pool_surveys(data)
# pool surveys
dates <- data %>%
unnest() %>%
mutate(date = as.character(date)) %>%
select(date) %>%
purrr::as_vector() %>%
unique() %>%
sort(decreasing = TRUE) %>%
as.Date(format = "%Y-%m-%d")
# pool surveys
dates <- as.Date("2018-01-10")
party_order <- coalishin::lookup_parties %>% filter(id_election == election) %>% arrange(position) %>% pull(id_party)
party_order <- coalishin::lookup_parties %>% filter(id_election == "ltw_by") %>% arrange(position) %>% pull(id_party)
data_pooled <- lapply(dates, function(date) pool_surveys(data, last_date = as.Date(date))) %>%
bind_rows() %>%
slice(order(match(party, party_order))) %>%
nest(-pollster, -date, -start, -end, -respondents) %>%
rename(survey = data) %>%
nest(-pollster) %>%
rename(surveys = data)
data_pooled
unnest(unnest(pooled))
unnest(unnest(data_pooled))
survey_pooled <- lapply(dates, function(date) pool_surveys(data, last_date = as.Date(date))) %>%
bind_rows() %>%
slice(order(match(party, party_order))) %>%
nest(-pollster, -date, -start, -end, -respondents) %>%
rename(survey = data) %>%
nest(-pollster) %>%
rename(surveys = data)
# Estimate probabilities --------------------------------------------------
survey <- survey_pooled
# Estimate probabilities --------------------------------------------------
survey <- survey_pooled %>% unnest()
survey
# simulate seat distributions
dirichlet.draws <- coalitions::draw_from_posterior(survey = survey, nsim = nsim, correction = correction)
# Estimate probabilities --------------------------------------------------
survey <- survey_pooled %>% unnest() %>% unnest()
# simulate seat distributions
dirichlet.draws <- coalitions::draw_from_posterior(survey = survey, nsim = nsim, correction = correction)
# simulate seat distributions
nsim <- 1000
dirichlet.draws <- coalitions::draw_from_posterior(survey = survey, nsim = nsim, correction = correction)
correction <- 0.005
dirichlet.draws <- coalitions::draw_from_posterior(survey = survey, nsim = nsim, correction = correction)
dirichlet.draws
seat.distributions <- coalitions::get_seats(dirichlet.draws, survey = survey,
distrib.fun = get(lookup_elections$distribution_function), n_seats = lookup_elections$parl_seats)
lookup_elections
lookup_elections$distribution_function
seat.distributions <- coalitions::get_seats(dirichlet.draws, survey = survey,
distrib.fun = get(lookup_elections$distribution_function[lookup_elections$id == "ltw_by"]),
n_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"])
# calculate coalition probabilities
res_all <- coalishin::calc_allCoalProbs(seat.distributions, parties, dirichlet.draws, strongest_party_coals = strongest_party_coals, cores = cores)
# calculate coalition probabilities
res_all <- coalishin::calc_allCoalProbs(seat.distributions, parties, dirichlet.draws, strongest_party_coals = strongest_party_coals)
# retrieve coalitions for which the party ordering is relevant (i.e. coalitions in lookup_coalitions that are stated multiple times in different ordering, e.g. "cdu|spd" and "spd|cdu")
coals <- lookup_coalitions %>% pull(id_coalition)
coals_sorted <- sapply(coals, function(x) paste(sort(strsplit(x, "\\|")[[1]]), collapse = "|"), USE.NAMES = FALSE)
if (any(table(coals_sorted) > 1)) {
name <- names(table(coals_sorted))[table(coals_sorted) > 1]
strongest_party_coals <- coals[which(coals_sorted == name)]
} else
strongest_party_coals <- NULL
if (any(table(coals_sorted) > 1)) {
name <- names(table(coals_sorted))[table(coals_sorted) > 1]
strongest_party_coals <- coals[which(coals_sorted == name)]
} else
strongest_party_coals <- NULL
coals_sorted
name <- names(table(coals_sorted))[table(coals_sorted) > 1]
name
strongest_party_coals <- coals[which(coals_sorted == name)]
# retrieve coalitions for which the party ordering is relevant (i.e. coalitions in lookup_coalitions that are stated multiple times in different ordering, e.g. "cdu|spd" and "spd|cdu")
coals <- lookup_coalitions %>% pull(id_coalition)
coals_sorted <- sapply(coals, function(x) paste(sort(strsplit(x, "\\|")[[1]]), collapse = "|"), USE.NAMES = FALSE)
coals_sorted
lookup_coalitions
# retrieve coalitions for which the party ordering is relevant (i.e. coalitions in lookup_coalitions that are stated multiple times in different ordering, e.g. "cdu|spd" and "spd|cdu")
coals <- lookup_coalitions %>% filter(id_election == "ltw_by") %>% pull(id_coalition)
coals_sorted <- sapply(coals, function(x) paste(sort(strsplit(x, "\\|")[[1]]), collapse = "|"), USE.NAMES = FALSE)
coals_sorted
if (any(table(coals_sorted) > 1)) {
name <- names(table(coals_sorted))[table(coals_sorted) > 1]
strongest_party_coals <- coals[which(coals_sorted == name)]
} else
strongest_party_coals <- NULL
name <- names(table(coals_sorted))[table(coals_sorted) > 1]
name
strongest_party_coals
# calculate coalition probabilities
res_all <- coalishin::calc_allCoalProbs(seat.distributions, parties, dirichlet.draws, strongest_party_coals = strongest_party_coals)
# calculate coalition probabilities
parties <- lookup_elections %>% filter(id == "ltw_by")
parties
# calculate coalition probabilities
parties <- lookup_parties %>% filter(id == "ltw_by")
# calculate coalition probabilities
parties <- lookup_parties %>% filter(id_election == "ltw_by")
parties
# calculate coalition probabilities
parties <- lookup_parties %>% filter(id_election == "ltw_by") %>% pull(id_party)
res_all <- coalishin::calc_allCoalProbs(seat.distributions, parties, dirichlet.draws, strongest_party_coals = strongest_party_coals)
# simulate seat distributions
nsim <- 100
correction <- 0.005
dirichlet.draws <- coalitions::draw_from_posterior(survey = survey, nsim = nsim, correction = correction)
seat.distributions <- coalitions::get_seats(dirichlet.draws, survey = survey,
distrib.fun = get(lookup_elections$distribution_function[lookup_elections$id == "ltw_by"]),
n_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"])
# retrieve coalitions for which the party ordering is relevant (i.e. coalitions in lookup_coalitions that are stated multiple times in different ordering, e.g. "cdu|spd" and "spd|cdu")
coals <- lookup_coalitions %>% filter(id_election == "ltw_by") %>% pull(id_coalition)
coals_sorted <- sapply(coals, function(x) paste(sort(strsplit(x, "\\|")[[1]]), collapse = "|"), USE.NAMES = FALSE)
if (any(table(coals_sorted) > 1)) {
name <- names(table(coals_sorted))[table(coals_sorted) > 1]
strongest_party_coals <- coals[which(coals_sorted == name)]
} else {
strongest_party_coals <- NULL
}
# calculate coalition probabilities
parties <- lookup_parties %>% filter(id_election == "ltw_by") %>% pull(id_party)
res_all <- coalishin::calc_allCoalProbs(seat.distributions, parties, dirichlet.draws, strongest_party_coals = strongest_party_coals)
res_all <- coalishin::calc_allCoalProbs(seat.distributions, c("csu","fdp"), dirichlet.draws, strongest_party_coals = strongest_party_coals)
res_all
# calculate coalition probabilities
parties <- c("csu","fdp")
# simulate seat distributions
nsim <- 1000
correction <- 0.005
dirichlet.draws <- coalitions::draw_from_posterior(survey = survey, nsim = nsim, correction = correction)
seat.distributions <- coalitions::get_seats(dirichlet.draws, survey = survey,
distrib.fun = get(lookup_elections$distribution_function[lookup_elections$id == "ltw_by"]),
n_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"])
# retrieve coalitions for which the party ordering is relevant (i.e. coalitions in lookup_coalitions that are stated multiple times in different ordering, e.g. "cdu|spd" and "spd|cdu")
coals <- lookup_coalitions %>% filter(id_election == "ltw_by") %>% pull(id_coalition)
coals_sorted <- sapply(coals, function(x) paste(sort(strsplit(x, "\\|")[[1]]), collapse = "|"), USE.NAMES = FALSE)
if (any(table(coals_sorted) > 1)) {
name <- names(table(coals_sorted))[table(coals_sorted) > 1]
strongest_party_coals <- coals[which(coals_sorted == name)]
} else {
strongest_party_coals <- NULL
}
# calculate coalition probabilities
parties <- c("csu","fdp")
res_all <- coalishin::calc_allCoalProbs(seat.distributions, parties, dirichlet.draws, strongest_party_coals = strongest_party_coals)
calc_oneCoal <- function(coal) {
# 1) extract the 0/1 vector of possible majorities for the coalition
browser()
maj <- res_shares %>% filter(coalition == coal) %>% select(-coalition) %>% t() %>% as.data.frame() %>% mutate(V1 = as.numeric(V1 > 0.5)) %>% pull(V1)
# 2) check if subset coalitions (or single parties) don't already have majorities on their own
party_vector <- strsplit(coal, split = "\\|")[[1]]
criterion_1 <- res_maj$coal_size < res_maj$coal_size[res_maj$coalition == coal]
criterion_2 <- sapply(res_maj$coalition, function(x) {
p <- strsplit(x, split = "\\|")[[1]]
all(p %in% party_vector)
}, USE.NAMES = FALSE)
subsetCoals <- res_maj$coalition[criterion_1 & criterion_2]
dat <- res_shares %>% filter(coalition %in% subsetCoals) %>% select(-coalition) %>% as.matrix() # The following operations are way faster on a numerical matrix than on a data.frame
dat <- (dat > 0.5)
aSubsetCoalitionIsPossible <- data.frame("maj" = apply(dat, 2, function(x) as.numeric(any(x)))) %>% pull(maj)
# 3) when a subset coalition has a majority the bigger coalition is not counted as possible
maj[aSubsetCoalitionIsPossible == 1] <- 0
# 3.1) special case: strongest_party_coals are only possible depending on the leading party in the coalition
if (!is.null(strongest_party_coals)) {
p <- strsplit(strongest_party_coals[1], "\\|")[[1]]
s_p <- list(shares[[p[1]]], shares[[p[2]]])
p2 <- strsplit(strongest_party_coals[2], "\\|")[[1]]
s_p2 <- list(shares[[p2[1]]], shares[[p2[2]]])
if(identical(party_vector, p)) {
maj[s_p[[1]] < s_p[[2]]] <- 0
maj[(s_p[[1]] == s_p[[2]]) & (shares_sim[,p[1]] < shares_sim[,p[2]])] <- 0 # for the case that the redistributed seats are exactly equal
} else if(identical(party_vector, p2)) {
maj[s_p2[[1]] < s_p2[[2]]] <- 0
maj[(s_p2[[1]] == s_p2[[2]]) & (shares_sim[,p2[1]] < shares_sim[,p2[2]])] <- 0
}
}
return(maj)
}
res_all <- calc_allCoalProbs(seat.distributions, parties, dirichlet.draws, strongest_party_coals = strongest_party_coals)
allShares <- res_all$shares_perSimulation
coalProbs <- res_all$coalProbs
# Plot --------------------------------------------------------------------
plot_seatDist_density(dirichlet.draws, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"])
dirichlet.draws
allShares <- res_all$shares_perSimulation
allShares
shares <- res_all$shares_perSimulation
shares <- shares %>% mutate(pollster = p, date = date_ins) %>% select(pollster, date, everything())
shares <- shares %>% mutate(pollster = "pooled", date = dates) %>% select(pollster, date, everything())
shares
# Plot --------------------------------------------------------------------
plot_seatDist_density(shares, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"])
setwd("~/Desktop/git/KOALA/KOALA_methods/201807_IWSM/Abstract/figures_codes")
plot_seatDist_density(shares, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"],
mark_CI = FALSE)
pdf("bauer_seatDist.pdf", width = 10, height = 4)
plot_seatDist_density(shares, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"],
mark_CI = FALSE)
dev.off()
pdf("../figures/bauer_seatDist.pdf", width = 15, height = 5)
plot_seatDist_density(shares, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"],
mark_CI = FALSE, base_size = 16)
dev.off()
pdf("../figures/bauer_seatDist.pdf", width = 20, height = 5)
plot_seatDist_density(shares, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"],
mark_CI = FALSE, base_size = 16)
dev.off()
pdf("../figures/bauer_seatDist.pdf", width = 20, height = 5)
plot_seatDist_density(shares, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"],
mark_CI = FALSE, base_size = 30)
dev.off()
pdf("../figures/bauer_seatDist.pdf", width = 20, height = 5)
plot_seatDist_density(shares, "pooled", coal = "csu|fdp", parl_seats = lookup_elections$parl_seats[lookup_elections$id == "ltw_by"],
mark_CI = FALSE, base_size = 40)
dev.off()
library(coalitions)
coalitions::pool_surveys
coalitions:::get_pooled
coalitions:::effective_samplesize
